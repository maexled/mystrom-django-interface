<script>
  /**
   * Load the result data from the REST API and render a chart into the given element
   * 
   * @param {number} id the id of the mystrom device
   * @param {number} elementId the id of the html element to render the chart in
   * @param {String} startDate the start date of the query
   * @param {String} endDate the end date of the query
   */
  async function loadMystromChart(id, elementId, startDate, endDate) {
    return new Promise((resolve) => {
      const startQuery = startDate == "" ? "" : "?start=" + startDate;
      const endQuery =
        endDate == "" ? "" : (startDate == "" ? "?" : "&") + "end=" + endDate;
      console.log(
        "Requesting REST: {% url 'rest_device_index' %}" +
        id.split("-")[1] +
        "/results/" +
        startQuery +
        endQuery
      );
      $.get(
        "{% url 'rest_device_index' %}" +
        id.split("-")[1] +
        "/results/" +
        startQuery +
        endQuery,
        data => {
          const chartElement = document.getElementById(elementId + "-chart");
          const informationElement = document.getElementById(
            elementId + "-information"
          );

          if (data.length == 0) {
            informationElement.innerHTML =
              '<h3 class="text-danger">Query of device ' +
              id +
              " is empty</h3>";
            console.log("Data is empty. Can not show any data");
            resolve();
            return;
          }
          const firstDate = new Date(data[0].date);
          const lastDate = new Date(data[data.length - 1].date);

          let currentHour = new Date(firstDate);
          currentHour.setMinutes(0);
          currentHour.setSeconds(0);
          currentHour.setMilliseconds(0);
          const powerPerHour = [];
          while (currentHour <= lastDate) {
            const nextHour = new Date(currentHour);
            nextHour.setHours(currentHour.getHours() + 1);
            const filteredData = data.filter(
              (entry) =>
                new Date(entry.date) >= currentHour &&
                new Date(entry.date) < nextHour
            );
            const powerList = filteredData.map((entry) => entry.power);
            let total = powerList.reduce((a, b) => a + b, 0);
  
            let percentageOfHour = 1;
            // if the first or last entry is not in the current hour, calculate the percentage of the hour
            if (firstDate - currentHour < 1000*60*60*24 && currentHour.getHours() == firstDate.getHours()) {
              percentageOfHour = (60 - firstDate.getMinutes()) / 60;
            } else if (lastDate - currentHour < 1000*60*60*24 && currentHour.getHours() == lastDate.getHours()) {
              percentageOfHour = lastDate.getMinutes() / 60;
            }
            const average = ((total / powerList.length) * percentageOfHour) / 1000;
            if (!isNaN(average)) {
              powerPerHour.push(average);
            } else {
              powerPerHour.push(0);
            }
            currentHour = nextHour;
          }

          const differenceBetweenDates = lastDate - firstDate;
          const hoursDifferenceBetweedDates =
            differenceBetweenDates / 1000 / 60 / 60;

          const powerList = data.map((entry) => entry.power);
          const wsList = data.map((entry) => entry.ws);
          const temperatureList = data.map((entry) => entry.temperature);
          let total = powerList.reduce((a, b) => a + b, 0);
          const average = total / powerList.length;
          const totalProducedkWh =
            (average * hoursDifferenceBetweedDates) / 1000;

          informationElement.innerHTML =
            "<h5>Average of " +
            hoursDifferenceBetweedDates.toFixed(2) +
            " hours: " +
            average.toFixed(2) +
            "Wh</h5>";
          informationElement.innerHTML +=
            "<h5>Leads to <b>" +
            totalProducedkWh.toFixed(2) +
            "kWh</b> produced in " +
            hoursDifferenceBetweedDates.toFixed(2) +
            " hours</h5>";
          
          informationElement.innerHTML +=
             "<h5>New Method Leads to <b>" +
              powerPerHour.reduce((a, b) => a + b, 0).toFixed(2) +
            "kWh</b> produced in " +
            hoursDifferenceBetweedDates.toFixed(2) +
            " hours</h5>";

          const xAxisList = data.map((entry) => entry.date);
          renderMystromChart(powerList, wsList, temperatureList, xAxisList, chartElement);
        }
      ).fail((jqXHR, textStatus, errorThrown) => {
        console.log("Error: " + errorThrown);
        console.log("Status: " + textStatus);
        const informationElement = document.getElementById(
          elementId + "-information"
        );
        if (informationElement)
          informationElement.innerHTML =
            '<h3 class="text-danger">Error while requesting data of device ' +
            id +
            "</h3>";
      }).always(() => {
        console.log("Request finished");
        resolve();
      });
    });
  }

  {% if CHART_TYPE == 'apexcharts' %}
  /**
   * Render the chart with the given data as apex chart
   * 
   * @param {Array} powerList the power list
   * @param {Array} wsList the ws list
   * @param {Array} temperatureList the temperature list
   * @param {Array} xAxisList the x axis list
   * @param {HTMLElement} chartElement the chart element to render the chart in
   */
  function renderMystromChart(powerList, wsList, temperatureList, xAxisList, chartElement) {
    const options = {
      series: [
        {
          name: "Power",
          data: powerList,
        },
        {
          name: "WS",
          data: wsList,
        },
        {
          name: "Temperature",
          data: temperatureList,
        },
      ],
      chart: {
        height: 500,
        type: "line",
        zoom: {
          enabled: true,
        },
      },
      colors: ["#C80815", "#6050dc", "#39FF14"],
      dataLabels: {
        enabled: false,
      },
      stroke: {
        width: 2,
        curve: "straight",
      },
      title: {
        text: "Power Usage",
        align: "left",
      },
      grid: {
        row: {
          colors: ["#f3f3f3", "transparent"], // takes an array which will be repeated on columns
          opacity: 0.5,
        },
      },
      xaxis: {
        categories: xAxisList,
        hideOverlappingLabels: true,
        tickAmount: 5,
      },
      yaxis: {
        decimalsInFloat: 2,
      },
    };
    // reducde series data when too much data is available
    if (options.series.length > 5000) {
      modolu = 10;
      options.series = options.series.map((series) => {
        const newData = [];
        console.log("SERIES: " + series.name + "");
        console.log(series.data);
        for (let i = 0; i < series.data.length; i++) {
          if (i % modolu == 0) {
            newData.push(series.data[i]);
          }
        }
        return {
          name: series.name,
          data: newData,
        };
      });
      options.xaxis.categories = options.xaxis.categories.filter(
        (category, index) => index % modolu == 0
      );
    }
    const chart = new ApexCharts(chartElement, options);
    chart.render();
  }

  {% elif CHART_TYPE == "uplot" %}
  /**
   * Render the chart with the given data as uPlot chart
   * 
   * @param {Array} powerList the power list
   * @param {Array} wsList the ws list
   * @param {Array} temperatureList the temperature list
   * @param {Array} xAxisList the x axis list
   * @param {HTMLElement} chartElement the chart element to render the chart in
   */
  function renderMystromChart(powerList, wsList, temperatureList, xAxisList, chartElement) {
    let data = [
      xAxisList.map((date) => new Date(date)/1000),
      powerList,
      wsList,
      temperatureList
    ];

    const opts = {
      width: chartElement.offsetWidth,
      height: 400,
      title: "Power Usage",
      tzDate: xAxisList => uPlot.tzDate(new Date(xAxisList * 1e3), 'Europe/Berlin'),
      drawOrder: ["series", "axes"],
      axes: [
        {
          label: "Time",
          values: (u, vals, space) => vals.map(v => new Date(v*1000).toLocaleTimeString().substring(0, 5) + "h"),
        },
        {
          values: (u, vals, space) => vals.map(v => v.toFixed(1) + "W/h"),
          label: "Power",
          space: 50,
          scale: "W/h",
          grid: {
            show: true,
            stroke: "rgba(0,0,0,0.2)",
            width: 1,
          },
          ticks: {
            show: true,
            stroke: "rgba(0,0,0,0.2)",
            width: 1,
          }
        },
      ],
      series: [
        {},
        {
          label: "Power",
          scale: "W/h",
          value: (u, v) => v == null ? null : v.toFixed(1) + "W/h",
          stroke: "red",
          width: 3 / devicePixelRatio,
        },
        {
          label: "WS",
          scale: "W/h",
          value: (u, v) => v == null ? null : v.toFixed(1) + "W/h",
          stroke: "blue",
          width: 2 / devicePixelRatio,
        },
        {
          label: "Temperature",
          scale: "W/h",
          value: (u, v) => v == null ? null : v.toFixed(1) + " Â°C",
          stroke: "green",
          width: 2 / devicePixelRatio,
        },
      ],
    };

    let u = new uPlot(opts, data, chartElement);
  }
  {% endif %}
</script>